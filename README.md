# BHS_NOD_TestTask

# Вступительное испытание
## Задание 1
Создать пустой проект: простой обход графа в глубину, написанный на языке C# в Visual Studio 2022.
### Описание графа
Граф — это структура данных, которая представляет собой набор вершин (узлов), связанных между собой ребрами. Граф позволяет представить отношения и взаимодействия между объектами или сущностями. Он должен представлять собой набор вершин, которые можно соединять между собой. Связи бывают двух типов: графовые (задают порядок обхода графа) и связи, передающие данные.
### Задача
Необходимо написать простой обход графа на примере складывания двух чисел.
### Требования
Для реализации задачи необходимо создать следующие классы:
1. Класс связей: 
   - Этот класс должен просто хранить ссылки на слот источника и таргета.
2. Два класса слотов:
   - Входной слот: должен хранить массив связей.
   - Выходной слот: должен хранить массив связей и может (по желанию) хранить данные. Также будет удобно иметь атрибут блока, к которому принадлежит слот.
3. Класс блока:
   - Должен иметь два слота, которые отвечают за обход графа (входной и выходной слоты).
   - Класс должен содержать два массива с входными и выходными слотами, отвечающими за передачу данных. Это упростит реализацию, но можно сделать и по-другому.
   - Желательно унаследовать все блоки от одного базового класса, в котором будут реализованы слоты и абстрактная функция (например, Run).
   - В функции Run можно реализовать основной функционал блока (например, сложение двух чисел) и логику перехода к следующему блоку. 
   - Рекомендуется использовать цикл for, который будет проходиться по массиву связей в выходном графовом слоте и вызывать функцию Run у связанных блоков. Подумайте, как лучше всего организовать эту логику.
### Пример
В данной реализации вы можете использовать различные структуры данных и подходы для достижения поставленной цели. Рекомендуется уделить внимание чистоте и читаемости кода, а также документированию каждого класса и метода.

# Условия задания
## Константные блоки
Для константных блоков также можно реализовать функцию Run, однако она будет пустой, что упростит процесс обхода графа. 
После создания всех классов в функции main необходимо инициализировать все блоки, соединить их и вызвать функцию Run у блока Entry Point, которая просто передаст управление связанным с ней блокам.
### Блоки
- Const: Константный блок, который хранит в себе константное число.
- Adder: Блок суммы, который на вход принимает 2 числа и на выходе выдает их сумму.
- Printer: Блок, который принимает число, полученное от блока Adder, и выводит его в консоль.
- Entry Point: Начальный блок, с которого начинается обход.
## Задание 2
Задание 2 состоит из трех задач. Первые две задачи являются обязательными и должны быть выполнены в полном объеме. Третья задача является дополнительной, и ее выполнение не обязательно, но успешное решение значительно повысит ваши шансы на получение вакансии. Даже частичное выполнение этой задачи будет рассмотрено как преимущество.
### Задачи
1. Максимальная глубина бинарного дерева: Дан корень бинарного дерева, необходимо вернуть его максимальную глубину. Максимальная глубина бинарного дерева — это количество узлов вдоль самого длинного пути от корневого узла до самого удаленного листового узла.
2. Количество островов: Дана двумерная бинарная сетка размером m x n, представляющая карту из '1' (земля) и '0' (вода). Необходимо вернуть количество островов. Остров окружен водой и образуется путем соединения соседних земель горизонтально или вертикально. Предполагается, что все четыре края сетки окружены водой.
### Дополнительная задача
Данная задача является необязательной, но значительно повышает шансы на получение вакансии.
3. Итератор для бинарного дерева поиска: Реализуйте класс BSTIterator, который представляет итератор по обходу бинарного дерева поиска (BST) в порядке in-order:
   - BSTIterator(TreeNode root): Инициализирует объект класса BSTIterator. Корень BST передается в качестве параметра конструктора. Указатель должен быть инициализирован на несуществующее число, меньшее любого элемента в BST.
   - boolean hasNext(): Возвращает true, если в обходе справа от указателя существует число, иначе возвращает false.
   - int next(): Перемещает указатель вправо, затем возвращает число на указателе.
Обратите внимание, что при инициализации указателя на несуществующее наименьшее число, первый вызов next() вернет наименьший элемент в BST. Можно предположить, что вызовы next() всегда будут допустимы, то есть при вызове next() в обходе всегда будет хотя бы одно следующее число.
