# BHS_NOD_TestTask

Вступительное испытание:
Задание 1:
Создать пустой проект: простой обход графа в глубину, написанный на языке C# в Visual Studio 2022.
Граф — это структура данных, которая представляет собой набор вершин (узлов), связанных между собой ребрами. Граф позволяет представить отношения и взаимодействия между объектами или сущностями.
Граф должен представлять собой набор вершин, которые можно соединять между собой. Связи бывают 2 типов: графовые (задают порядок обхода графа, треугольники на рисунке) и связи, передающие данные (кружки на рисунке). 

Необходимо написать простой обход графа на примере складывания 2-х чисел.
Для этого:
Необходимо создать классы:
Класс связей (просто хранит ссылки на слот источника и таргета);
2 класса слотов (входной и выходной) – классы слотов должны хранить массив связей, а выходные слоты могут хранить данные (но это на ваше усмотрение). Ещё удобно будет иметь атрибут блока, к которому принадлежит слот;
Класс блока – должен иметь 2 слота, которые будут отвечать за обход графа (треугольники на рисунке), то есть класс должен иметь 2 атрибута (входной и выходной слот, треугольники на рисунке). Также класс должен содержать 2 массива с входными и выходными слотами, отвечающими за передачу данных (так будет проще, но можете сделать и по-другому). Желательно унаследовать все блоки от 1 базового класса, в котором будет реализованы слоты и абстрактная функция (например Run), в которой можно реализовать основной функционал блока (например сложение двух чисел) и логику перехода к следующему блоку (лучше просто сделать for, который будет проходиться по массиву связей в выходном графовом слоте и вызывать функцию Run у связанных блоков, подумайте, как это лучше сделать);
Для константных блоков тоже можно реализовать функцию Run, но она будет пустая, так будет проще делать обход.
После создания всех классов в функции main инициализируйте все блоки соедините блоки и вызовете функцию Run у блока Entry Point, которая просто передает управление связанным с нею блокам.
Блоки:
Const (Константный блок, который хранит в себе константное число);
Adder (Блок суммы, который на вход принимает 2 числа, а на выходе выдаёт их сумму);
Printer (На вход принимает число, которое посчитает Adder и выводит в консоль);
Entry point (Начальный блок, с которого начинается обход).
Задание 2 состоит из трёх задач.
Первые две задачи являются обязательными и должны быть выполнены в полном объеме.
Третья задача является дополнительной и её выполнение не обязательно, но успешное решение значительно повысит ваши шансы на получение вакансии. Даже частичное выполнение этой задачи будет рассмотрено как преимущество.
Все задачи необходимо выполнить на языке C#.

Дан корень бинарного дерева, верните его максимальную глубину. Максимальная глубина бинарного дерева — это количество узлов вдоль самого длинного пути от корневого узла до самого удалённого листового узла.

Дана двумерная бинарная сетка размером m x n, представляющая карту из '1' (земля) и '0' (вода). Верните количество островов. 
Остров окружен водой и образуется путём соединения соседних земель горизонтально или вертикально. Можно предположить, что все четыре края сетки окружены водой.

*Данное задание является необязательным, однако значительно повышают шанс прохождения на данную вакансию*
Реализуйте класс BSTIterator, который представляет итератор по обходу бинарного дерева поиска (BST) в порядке in-order:
BSTIterator(TreeNode root): Инициализирует объект класса BSTIterator. Корень BST передается в качестве параметра конструктора. Указатель должен быть инициализирован на несуществующее число, меньшее любого элемента в BST.
boolean hasNext(): Возвращает true, если в обходе справа от указателя существует число, иначе возвращает false.
int next(): Перемещает указатель вправо, затем возвращает число на указателе.
Обратите внимание, что при инициализации указателя на несуществующее наименьшее число, первый вызов next() вернет наименьший элемент в BST.
Можно предположить, что вызовы next() всегда будут допустимы. То есть, при вызове next() в обходе всегда будет хотя бы одно следующее число.
